/dev/shm/jobmon/$JOBID.config

/dev/shm/jobmon/$JOBID.progress

/dev/shm/jobmon/$JOBID.env

which are in a defined format. Here $JOBID is an application string which should start with SLURM assigned job id and may then include rank or other app-defined key material. An ldmsd sampler can then scan /dev/shm/jobmon/ for new files and collect data safely.

The library could follow a singleton pattern (global) or support thread-level or object level use. For now assume singleton ldms_watch_ and app is responsible for calling only in rank 0 or equivalent. More object-oriented usage, arrays, and per-rank usage should be obvious extensions.

void ldms_watch_init($JOBID, app_name, app_family)  // e.g ("12345", "bobsMDversion", "lammps")

void ldms_watch_continuation(previous_job)       // tell us the prior job in simulation time

void ldms_watch_final()                          // dump any outstanding data

 

// collecting configuration strings

void ldms_watch_config_init(max_data_bytes)           // define maximum file size

void ldms_watch_config_add_value(key, value)          // add a string

void ldms_watch_config_add_kvlist(map)                // add a list of string key:value pairs

void ldms_watch_config_add_group(group_name)          // name a subset of strings

void ldms_watch_config_add_group_value(group_name, key, value)   // add value to a group

void ldms_watch_config_add_group_kvlist(group_name, map)         // add list to a group

void ldms_watch_config_write()                        // write all config strings to file

 

// collecting progress (rolling unsigned iteration counters)

void ldms_watch_progress_init(max_data_bytes)         // define maximum file size

point = ldms_watch_progress_add("point_name")         // name a progress point counter

ldms_watch_progress_update(point)                     // update the counter

ldms_watch_progress_write()                           // write all counters to file

lmds_watch_progress_schedule_write(interval, offset)  // schedule automatic writing of counters in an independent thread

 

// log significant environment variables

void ldms_watch_env(envvar)                           // add named environment variable to dump

void ldms_write_env()                                 // dump all named variables to file

The progress and config init functions accept a maximum file size. If later in the code too many values or progress points are added such that the file size will be exceeded, the excess adds are ignored and an error counter in the output becomes non-zero. It's trivial to adjust this scheme to force error-handling on the application writer if desired and to accept max=0 as a flag that the app writer wants no limitations. The LDMS sampler may, however, impose limitations such that app data is lost.

Feedback from lammps developers

    Include a (bounded) log recording capability rather than exclusively a parameter tabulation; don't know the parameters of interest going into the future.
    Telling laamps folk "lammps-hours" without any configuration info is also of great interest. (we could get this from the BU pid sampler and offline introspection of binaries detected. (nm $binary |grep -i lammps)
    Expect the case of a single slurm job with hundreds of separate app runs inside, include N-cores simultaneous serial runs.
    Make sure it can be defaulted off at the developers discretion.
    Turning it on via an environment variable is acceptable.
    No immediate bite on the "progress" feature
    Provide us a demo code + proposed instrumentation library.
    Performance concerns:
        memory competition (allow strict upper bound)
        cleanup of files when a run ends but after ldms has sampled them. Whose job?
        Impact of instrumentation on runtime performance.
        per node vs per rank reporting.
        Lammps can spawn vasp-- how is that accounted?
        Not per-thread reporting.
        How will this behave in non-sandia environments?
        lammps can periodically replay some or all of an input file; consider mode where only first N log lines are kept.

 
